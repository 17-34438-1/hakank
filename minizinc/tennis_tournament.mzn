% 
% Tennis tournament in MiniZinc.
% 
% http://stackoverflow.com/questions/4747498/tennis-match-scheduling
% """
% Tennis match scheduling

% There are a limited number of players and a limited number of tennis courts. At each 
% round, there can be at most as many matches as there are courts. Nobody plays 2 rounds without a 
% break. Everyone plays a match against everyone else. Produce the schedule that takes as few 
% rounds as possible. (Because of the rule that there must a break between rounds for everyone, 
% there can be a round without matches.) The output for 5 players and 2 courts could be:

%  |  1   2   3   4   5
%  -|------------------- 
%  2|  1   - 
%  3|  5   3   - 
%  4|  7   9   1   - 
%  5|  3   7   9   5   -

% In this output the columns and rows are the player-numbers, and the numbers inside the matrix 
% are the round numbers these two players compete.

% The problem is to find an algorithm which can do this for larger instances in a feasible time. 
% We were asked to do this in Prolog, but (pseudo-) code in any language would be useful.

% My first try was a greedy algorithm, but that gives results with too many rounds. Then I 
% suggested an iterative deepening depth-first search, which a friend of mine implemented, but 
% that still took too much time on instances as small as 7 players.
% """

% The matches above are

% Match   Player1  Player2
% ------------------------
% 1       1        2         1
% 1       3        4         2
% 3       2        3         3
% 3       1        5         4
% 5       1        3         5
% 5       4        5         6
% 7       1        4         7
% 7       2        5         8
% 9       2        4         9
% 9       3        5        10

% Player 1 = matches 1,3,5,7
% Player 2 = matches 1,3,7,9
% Player 3 = matches 1,3,5,9,
% Player 4 = matches 1,5,7,9
% Player 5 = matches 3,5,7,9
% (Note the nice pattern of matches: all players have a unique odd number ordering)


% mat's solution on 6 players and 2 courts
%    1  2  3  4  5  6
%    ----------------
% 1  -  1  3  5  7 10
% 2  -  -  6  9 11  3
% 3  -  -  - 11  9  1
% 4  -  -  -  -  2  7
% 5  -  -  -  -  -  5
% 6  -  -  -  -  -  -

% Match   P1 P2
%  1      1  2     1
%  1      3  6     2
%  2      4  5     3
%  3      1  3     4
%  3      2  6     5
%  5      1  4     6
%  5      5  6     7
%  6      2  3     8
%  7      1  5     9
%  7      4  6    10
%  9      2  4    11
%  9      3  5    12
% 10      1  6    13
% 11      2  5    14
% 11      3  4    15

% Player 1: 1 3 5 7 10
% Player 2: 1 3 6 9 11 
% Player 3: 1 3 6 9 11
% Player 4: 2 5 7 9 11
% Player 5: 2 5 7 9 11
% Player 6: 1 3 5 7 10

% mat's solution on 7 players on 5 courts  (13 matches)
% [ -, 1, 3, 5, 7, 9,11]
% [ 1, -, 5, 3,11,13, 9]
% [ 3, 5, -, 9, 1, 7,13]
% [ 5, 3, 9, -,13,11, 7]
% [ 7,11, 1,13, -, 5, 3]
% [ 9,13, 7,11, 5, -, 1]
% [11, 9,13, 7, 3, 1, -]


%
% Generated by this model: 10 players 2 courts (23 matches)
%
% Player's matrix:
%
%  - 15 19 12  1 21 10  4 23  7 
% 15  - 17  9 11  6  3 21 13 19 
% 19 17  - 14 22  4 12  6  2  9 
% 12  9 14  - 18 16  7  2 20  5 
%  1 11 22 18  - 14 20 16  8  3 
% 21  6  4 16 14  -  1  8 18 11 
% 10  3 12  7 20  1  - 23  5 17 
%  4 21  6  2 16  8 23  - 10 13 
% 23 13  2 20  8 18  5 10  - 15 
%  7 19  9  5  3 11 17 13 15  - 


% 
% This MiniZinc model was created by Hakan Kjellerstrand, hakank@gmail.com
% See also my MiniZinc page: http://www.hakank.org/minizinc/
%

include "globals.mzn"; 

int: n; % number of players
int: num_courts; % number of courts

int: m = n*(n-1) div 2; % number of matches

% decision variables
array[1..n, 1..n] of var 0..m: x;

var 0..m: z = max(array1d(x)); % max number of match (to minimize)

% predicates

% solve minimize z;
solve :: int_search(array1d(x), most_constrained, indomain_split, complete) minimize z;

constraint


  % upper triangle
  forall(k in 1..n) (
    % sum([x[i,j]=k | i,j in 1..n where i < j]) <= num_courts
    at_most(num_courts, [x[i,j]=k | i,j in 1..n where i < j], k)
  )

  /\
  forall(i in 1..n) (
    x[i,i] = 0 /\
    forall(j in 1..n where i != j) (
      x[i,j] > 0 /\
      x[i,j] = x[j,i]
    )
  )
  /\ % a player must rest at least one match after a match
  forall(p in 1..n) (
    forall(p2,p3 in 1..n where p2 != p /\ p3 != p /\ p2 < p3) (
      abs(x[p,p2]-x[p,p3]) >= 2
    )
  )

  /\ % symmetry breaking
     % first player's game are sorted
  increasing([x[1,j]| j in 1..n])

  /\ x[1,2] = 1
;

output 
[
  "n: \(n) num_courts: \(num_courts)\n",
  "z: \(z)\n",
]
++
[ "\n\nMatches:\n"] 
++
[
  if fix(x[p1,p2]) = match then
    "Match " ++ show_int(2,match) ++ ": " ++ show_int(2,p1) ++ " vs " ++ show_int(2,p2) ++ "\n"
  else
   ""
  endif
  | match in 1..fix(z), p1,p2 in 1..n where p1 < p2
]
++
[ "\nMatch grid:\n"]
++
[
  if j = 1 then "\n" else " " endif ++
    show_int(3, x[i,j])
  | i,j in 1..n
]
++
[
 "\nz: \(z)\n"
]
;

%
% data
%
n = 7;
num_courts = 5;
