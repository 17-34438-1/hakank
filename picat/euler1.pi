/* 

  Euler #1 in Picat.

  Problem 1
  """
  If we list all the natural numbers below 10 that are multiples of 3 or 5, 
  we get 3, 5, 6 and 9. The sum of these multiples is 23.
  Find the sum of all the multiples of 3 or 5 below 1000.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

import cp.
import util.

main => time(go).

go => euler1.

go2 => 
   euler1,
   euler1b,
   euler1c,
   euler1d,
   euler1e,
   euler1f,
   euler1g,
   euler1h,
   euler1i,
   euler1j,
   euler1k,
   euler1l,
   euler1m.


euler1 => 
   writeln(sum([I: I in 1..999, (I mod 3== 0; I mod 5==0)])).

%
% Some alternative approaches
%
euler1b =>
   Sum = 0,
   foreach(I in 1..999)
      if I mod 3 == 0; I mod 5 == 0 then
        Sum := Sum + I
      end
   end,
   writeln(Sum).


pred1c(N) = cond((N mod 3 == 0; N mod 5 == 0), 1, 0).
euler1c => 
   writeln(sum([I*pred1c(I): I in 1..999])).

euler1d => 
   writeln(sum([cond((I mod 3 == 0; I mod 5 == 0), 1, 0)*I: I in 1..999])).

pred1e(N) => N mod 3 == 0; N mod 5 == 0.
euler1e => 
   writeln(sum([I: I in 1..999, pred1e(I)])).


pred1f(N), N mod 3 == 0 => true.
pred1f(N), N mod 5 == 0 => true.
euler1f => 
   writeln(sum([I: I in 1..999, pred1f(I)])).
   

euler1g => 
   L = findall(N, (member(N, 1..999), pred1f(N))),
   writeln(sum(L)).

% using CP and reification (this is a little contrieved)
euler1h =>  
   Len = 999,
   X = new_list(Len),
   X :: 0..1, 
   foreach(I in 1..Len) 
      I mod 3 #= 0 #\/ I mod 5 #= 0 #<=> X[I] #= 1
   end,

   Sum #= sum([I*X[I] : I in 1..Len]),
   solve(X),
   writeln(Sum).

% another CP approach
euler1i =>  
   X #= [I*(I mod 3 #= 0 #\/ I mod 5 #= 0) : I in 1..999],
   Sum #= sum(X),
   solve(X),
   writeln(Sum).

euler1j => 
   % writeln(union2(3..3..999, 5..5..999).sum()).
   writeln(sort_remove_dups(3..3..999++5..5..999).sum()).

union2(A,B) = C =>
    bp.sort(A++B,C).

% using \/ (or) on 0/1 lists
euler1k => 
   N = 999,
   L3 = [cond(I mod 3==0,1,0) : I in 1..N],
   L5 = [cond(I mod 5==0,1,0) : I in 1..N],
   println(sum([I : {I,V} in zip(1..N, map(\/,L3,L5)), V=1])).

euler1l => 
   writeln(sum([I*cond((I mod 3== 0; I mod 5==0),1,0) : I in 1..999])).


% Using an acumulator 
p1m(N,Limit,S) => p1m(N,Limit,0,S).
p1m(N,Limit,S1,S2) ?=> 
  N > Limit, S1=S2.
p1m(N,Limit,S1,S2) ?=> 
  (N mod 3 = 0; N mod 5 = 0),
  p1m(N+1,Limit,S1+N,S2).
p1m(N,Limit,S1,S2)  => 
  p1m(N+1,Limit,S1,S2).

euler1m =>
  p1m(1,999,S),
  println(S).