#!/usr/bin/env setl
-- 
-- Project Euler problem 12 in SETL
--
-- Problem 12
-- """
-- The sequence of triangle numbers is generated by adding the natural numbers. 
-- So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
-- The first ten terms would be:
--
-- 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
--
-- Let us list the factors of the first seven triangle numbers:
--
--      1: 1
--      3: 1,3
--      6: 1,2,3,6
--     10: 1,2,5,10
--     15: 1,3,5,15
--     21: 1,3,7,21
--     28: 1,2,4,7,14,28
--
-- We can see that the 7th triangle number, 28, is the first triangle number 
-- to have over five divisors.
--
-- Which is the first triangle number to have over five-hundred divisors?")
-- """
--
--
-- This SETL program was created by Hakan Kjellerstrand (hakank@bonetmail.com)
-- Also see my SETL page: http://www.hakank.org/setl/
--

-- takes about 3 seconds
-- intslash := true; -- "magic" for handing "/" as "div"
problem12();


proc problem12();
    nprint("Problem 12: ");
    lenx := 0;
    i := 0;
    tnum := 0;
    while lenx <= 500 loop
        i +:= 1;
        tnum +:= i;
        lenx := num_divisors(tnum);
        -- print("n: ", tnum, " len: ", lenx);
    end loop;

    -- print(tnum, " len:", lenx, " i:", i);
    print(tnum);

end proc;

--
-- number of divisors
---
-- multiply the exponents and add 1
--
-- See http://en.wikipedia.org/wiki/Divisor_function
--
proc num_divisors(n);
     return */[ e+1 : [p,e] in collect(prime_factors(n))];
end proc;


--
-- collect
--
-- Return a map with the number of occurrences of each number
-- in the tuple a.
--
proc collect(a);

  -- d := { i : i in a};
  -- c := { [i, #[j : j in [1..#a] | a(j) = i ]] :  i in d}; 

  c:= {};
  -- simpler version. Note: the tuple must be assigned to a variable.
  -- p:= [ (c(i) +:= 1) : i in a];

  -- this is faster
  for i in a loop
    c(i) +:= 1;
  end loop;

  return c; 
end proc;


procedure prime_factors(n);
    facts := [];
    -- while even(n) loop facts with:= 2; n /:= 2; end loop;
    while even(n) loop facts with:= 2; n := n div 2; end loop;
    while exists k in [3,5..ceil(sqrt(float(n)))] | n mod k = 0 loop
       facts with:= k; 
       -- n /:= k;
       n := n div k;
    end loop;
   facts with:= n;

   return facts;

end prime_factors;


--
-- not used (quite slow)
--
-- proc num_divisors1(n);
--    s := 0;
--    for i in [1..round(sqrt(n))] loop
--        if n mod i = 0 then
--            s +:= 1;
--        end if;
--    end loop;
--    return(s);
-- end proc;
--

--
-- not used
--
-- proc triangle_number(n);
--    return +/[i : i in [1..n]];
-- end proc;
--
