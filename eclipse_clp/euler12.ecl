% 
%  Problem 12
%  """
%  The sequence of triangle numbers is generated by adding the natural numbers. 
%  So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
%  The first ten terms would be:
% 
%  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
% 
%  Let us list the factors of the first seven triangle numbers:
% 
%       1: 1
%       3: 1,3
%       6: 1,2,3,6
%      10: 1,2,5,10
%      15: 1,3,5,15
%      21: 1,3,7,21
%      28: 1,2,4,7,14,28
% 
%  We can see that the 7th triangle number, 28, is the first triangle number 
%  to have over five divisors.
% 
%  Which is the first triangle number to have over five-hundred divisors?")
%  """
%
%  Answer: 76576500
%
%  [n : 12375, triangle_number : 76576500, len : 576]
%

:- lib(hash).
:- lib(listut).

%
% From http://rosettacode.org/wiki/Prime_decomposition#Prolog
% This is faster than prime_factors3/2.
% hakank: I had to add integer/1, floor/1, and // (instead of /)
%
prime_decomp(N, L) :-
	SN is integer(floor(sqrt(N))),
	prime_decomp_1(N, SN, 2, [], L).
 
 prime_decomp_1(1, _, _, L, L) :- !.
 
% Special case for 2, increment 1
prime_decomp_1(N, SN, D, L, LF) :-
	(   0 is N mod D ->
	    Q is N // D,
	    SQ is integer(floor(sqrt(Q))),
	    prime_decomp_1(Q, SQ, D, [D |L], LF)
	;
	    D1 is D+1,
	    (	D1 > SN ->
	        LF = [N |L]
	    ;
	        prime_decomp_2(N, SN, D1, L, LF)
	    )
	).
 
% General case, increment 2
prime_decomp_2(1, _, _, L, L) :- !.
 
prime_decomp_2(N, SN, D, L, LF) :-
	(   0 is N mod D ->
	    Q is N // D,
	    SQ is integer(floor(sqrt(Q))),
	    prime_decomp_2(Q, SQ, D, [D |L], LF);
	    D1 is D+2,
	    (	D1 > SN ->
	        LF = [N |L]
	    ;
	        prime_decomp_2(N, SN, D1, L, LF)
	    )
	).



problem12_tmp :-
        N = 500,
        p12(1,N,1,T), 
        % writeln(T), 
        length(T,Len), 
        Len1 is Len-1,
        nth1(Len1, T,Last), 
        writeln(Last).

% (0.34s)
problem12 :- once problem12_tmp.


p12(N,Val,T,[T2|L]) :-

        % using divisors2/2 takes about 7.5 seconds.
        % divisors2(T,Divisors),
        % length(Divisors, Len),

        % using num_divisors/2 with prime_factors/2 takes 
        % much longer: 115 seconds
        % with prime_factors3/2: 0.48s
        % Later: when using prime_decomp/2 in num_divisors: 0.3s!
        num_divisors(T,Len),
        % writeln([n:N, triangle_number:T, len:Len]),
        (Len >= Val ->  
             writeln([n:N, triangle_number:T, len:Len]),
             true
        ; 
            Len < Val,
            N2 is N+1,
            T2 is T+N2,
            p12(N2,Val,T2,L)
        ).

% Later: using num_divisors/2 takes 0.32s
% Though we must hard code the limit in the loop.
problem12b :-
        Limit = 500,
        ( for(I,1, 15000),
          param(Limit) do
              p12b(I,T,Len),
              Len >= Limit ->
              writeln(solution:[T,Len]),
              % we want only the first solution
              fail
        ;
              true
        ).

p12b(N, T, Len) :-
        triangle(N,T),
        % divisors2(T,Divisors), % takes 7.7 seconds
        % length(Divisors, Len)
        num_divisors(T,Len). % much faster: 0.32s

% Brute force version
divisors(N, Divisors2) :-
        X is integer(1+(N // 2)), 
        ( for(I,1,X), 
          fromto(Divisors,Out,In,[]),
          param(N) do 
              N mod I =:= 0 -> 
              Out = [I|In] 
        ; 
              Out = In
        ),
        eclipse_language:append(Divisors,[N], Divisors2).

%
% Here we just take the divisors
% from 2..sqrt(N) and then add the rest (N mod Divisors).
% For some N the last element in Divisors1 is the same as
% first element in Divisors2 which we must handle.
% This happens when N is a square.
%
% This is faster than divisors/2.
%
divisors2(N, Divisors) :-
        N1 is N+1,
        X is integer(floor(sqrt(N1))), 

        % get the first half of the divisors
        ( for(I,1,X), 
          fromto(Divisors1,Out1,In1,[]),
          param(N) do 
              N mod I =:= 0 -> 
              Out1 = [I|In1]
        ; 
              Out1 = In1
        ),
        % now make the second half
        ( foreach(D1,Divisors1),
          foreach(D2,Divisors2),
          param(N) do
              D2 is N // D1
        ),
        % When N is a square we must remove the first element in 
        % the reversed list (since it's the same as the last in the
        % first list)
        eclipse_language:reverse(Divisors2,Divisors2b),
        last_element(Divisors1, Last1),
        Divisors2b = [First2b|Divisors2c],
        (
            Last1 \= First2b ->
                eclipse_language:append(Divisors1,Divisors2b,Divisors)
        ;
                eclipse_language:append(Divisors1,Divisors2c,Divisors)
        ).   

last_element(List,Last) :-
        length(List,Len),
        nth1(Len,List,Last).
        
% Is N a square number?
is_square(N) :- 
        Y is integer(floor(sqrt(N))),
        N =:= Y*Y.
        


% This version requires that we know the length...
% problem12d :-
%         N = 500,
%         ( for(I,1,N), 
%           foreach(T,TriangleNumbers), 
%           foreach(ND,NumDivisors), 
%           fromto(0,In,Out,_Sum) do 
%               Out is In+I, 
%               T = Out,
%               divisors2(Out, Divisors),
%               length(Divisors, ND),
%               writeln([I,Divisors,ND])
%         ),
%         writeln(TriangleNumbers),
%         writeln(NumDivisors),
%         eclipse_language:max(NumDivisors, Max),
%         writeln(Max).


%
% num_divisors
%  in SETL:  return */[ e+1 : [p,e] in collect(prime_factors(n))];
% See http://en.wikipedia.org/wiki/Divisor_function
%
% Though it's much slower (for problem12) than divisors2/2.
%
num_divisors(N,NumDivisors) :-
        % prime_factors(N, Factors), % slow
        % prime_factors3(N, Factors), % faster
        prime_decomp(N, Factors), % fastest
        hash_create(FHash),
        ( foreach(F,Factors),
          param(FHash) do
              hash_get(FHash, F, Val) ->
              Val2 is Val + 1,
              hash_add(FHash, F, Val2)
        ;
              hash_add(FHash, F, 1)
        ),
        hash_list(FHash,_Keys, Values),
        ( foreach(V,Values),
          fromto(1,In,Out,NumDivisors) do
              Out is In*(V+1)
        ).


%
% The N'th triangle number is n*(n+1) / 2
%
% (for(I,1,10), foreach(T,Triangle) do triangle(I,T)).
%
% I = I
% T = T
% Triangle = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55]
triangle(N, T) :- T is N *(N+1) // 2.

go :-
        writeln('problem12'),
        problem12,
        writeln('problem12b'),
        problem12b.